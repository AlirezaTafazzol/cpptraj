#include <cstdio>  // sprintf
#include <cstdlib> // atof
#include <cstring> // memset
#include "BufferedFile.h"
#include "CpptrajStdio.h"

BufferedFile::BufferedFile() :
  buffer_(0),
  bufferPosition_(0),
  frameSize_(0),
  offset_(0),
  Ncols_(0),
  eltWidth_(0),
  tokenptr_(tokens_.begin()),
  saveChar_(0),
  lineEnd_(0),
  endChar_(0),
  endBuffer_(0)
{ }

BufferedFile::~BufferedFile() {
  if (buffer_!=0) delete[] buffer_;
}

// -----------------------------------------------------------------------------
// BufferedFile::SetupBuffer()
int BufferedFile::SetupBuffer() {
  if (buffer_!=0) delete[] buffer_;
  buffer_ = new char[ DEFAULT_BUFFERSIZE + 1];
  buffer_[ DEFAULT_BUFFERSIZE ] = '\0';
  bufferPosition_ = buffer_;
  endBuffer_ = bufferPosition_; // This guarantees on first BufferedLine buffer will be filled
  lineEnd_= bufferPosition_;
  return 0;
} 

// BufferedFile::BufferedLine()
const char* BufferedFile::BufferedLine() {
  *lineEnd_ = endChar_;
  bufferPosition_ = lineEnd_;
  // Search for next end line 
  lineEnd_ = bufferPosition_;
  while (lineEnd_ <= endBuffer_) {
    // Fill buffer if needed
    if (lineEnd_ == endBuffer_) {
      size_t bufferRemainder = endBuffer_ - bufferPosition_;
      if (bufferRemainder == DEFAULT_BUFFERSIZE) break;
      memcpy(buffer_, bufferPosition_, bufferRemainder);
      int Nread = Read(buffer_ + bufferRemainder, DEFAULT_BUFFERSIZE - bufferRemainder);
      if (Nread < 1) return 0;
      lineEnd_ = bufferPosition_ = buffer_;
      endBuffer_ = buffer_ + bufferRemainder + (size_t)Nread;
      // TODO: Check if this has happened multiple times with no endline
    }
    if ( *(lineEnd_++) == '\n') {
      // End of the line
      endChar_ = *lineEnd_;
      *lineEnd_ = '\0';
      return bufferPosition_;
    }
  }
  // Should never get here
  mprinterr("Internal Error: Input line size > internal buffer size (%lu)\n", 
            DEFAULT_BUFFERSIZE);
  return 0;
}

/** Separate the current line into tokens delimited by given chars. 
  * \return Number of tokens.
  */
int BufferedFile::TokenizeLine(const char* separator) {
  if ( separator == 0 ) return 0;
  char* linechar = bufferPosition_;
  bool inToken = false;
  tokens_.clear();
  // NOTE: Just check for newline?
  while ( *linechar != '\0' && *linechar != '\n' ) {
    if (!inToken) { // Not in token.
      if ( strchr( separator, *linechar ) == 0 ) {
        tokens_.push_back( linechar); // Pointer to beginning of token.
        inToken = true;
      }
    } else {        // In a token.
      if ( strchr( separator, *linechar ) != 0 ) {
        tokens_.push_back( linechar ); // Pointer to end of token.
        inToken = false;
      }
    }
    ++linechar;
  }
  // If inToken is still true point to linechar as the last token
  if (inToken)
    tokens_.push_back(linechar);
  tokenptr_ = tokens_.begin();
  /*mprintf("DBG: Tokenize: Line=[%s]\n", linebuffer_);
  mprintf("\t%i Tokens:\n", ntokens);
  for (unsigned int t = 0; t < ntokens; ++t)
    mprintf("\t\t%u %c\n",t, *tokens_[t]);*/
  return (int)(tokens_.size() / 2);
}

/** Following a call to TokenizeLine return char* to next token in the
  * line. Token is generated by inserting a null char at the current
  * token end position; this char is restored once NextToken is called
  * again.
  */
const char* BufferedFile::NextToken() {
  if (tokenptr_ == tokens_.end()) return 0;
  if (tokenptr_ != tokens_.begin())
    *(*(tokenptr_ - 1)) = saveChar_;
  saveChar_ = *(*(tokenptr_ + 1));
  *(tokenptr_ + 1) = '\0';
  char* tokenpos = tokenptr_[0];
  tokenptr_ += 2;
  return tokenpos;
}

// -----------------------------------------------------------------------------
// BufferedFile::SetupFrameBuffer()
size_t BufferedFile::SetupFrameBuffer(int Nelts, int eltWidthIn, int eltsPerLine)
{
  return SetupFrameBuffer(Nelts, eltWidthIn, eltsPerLine, 0, 0);
}

/** Prepare the buffer to receive organized chunks of text, i.e. 
  * organized in some regular fashion (e.g. an Amber Traj, which
  * is 10 cols of 8.3 precision floating point numbers etc).
  * \param Nelts Total expected number of elements to read.
  * \param eltWidth Width in chars of each element.
  * \param eltsPerLine Number of elements per line (columns).
  * \param additionalBytes Any additional bytes in the frame.
  * \param offsetIn Offset to be used in seeking.
  * \return Size of set-up frame.
  */
size_t BufferedFile::SetupFrameBuffer(int Nelts, int eltWidthIn, int eltsPerLine, 
                                      size_t additionalBytes, int offsetIn) 
{
  Ncols_ = eltsPerLine;
  eltWidth_ = (size_t)eltWidthIn;
  offset_ = (size_t) offsetIn;
  frameSize_ = CalcFrameSize( Nelts ) + additionalBytes;
  if (buffer_!=0) delete[] buffer_;
  if (frameSize_ < 1) 
    buffer_ = 0;
  else {
    buffer_ = new char[ frameSize_ ];
    memset(buffer_, 0, frameSize_);
  }
  bufferPosition_ = buffer_;
  return frameSize_;
}

/** Based on the current values of Ncols and eltWidth, calculate size
  * in bytes necessary to buffer Nelts.
  */
size_t BufferedFile::CalcFrameSize( int Nelts ) {
  int frame_lines = Nelts / Ncols_;
  if ((Nelts % Ncols_) > 0) 
    ++frame_lines;
  bool readingFile = (Access() == CpptrajFile::READ);
  // If Reading and DOS, CR present for each newline
  if (readingFile && IsDos()) frame_lines *= 2;
  // Calculate total frame size
  size_t fsize = (((size_t)Nelts * eltWidth_) + frame_lines);
  // If writing, add +1 for null 
  if (!readingFile)
    ++fsize;
  return fsize;
}

/** Increase size of buffer by delta elements, keeping contents intact. */
size_t BufferedFile::ResizeBuffer(int delta) {
  if (delta == 0) return frameSize_;
  if (delta < 0) {
    mprinterr("Internal Error: ResizeBuffer: Negative value given.\n");
    return frameSize_;
  }
  size_t newsize = frameSize_ + CalcFrameSize( delta );
  char* newbuffer = new char[ newsize ];
  memcpy(newbuffer, buffer_, frameSize_);
  memset(newbuffer+frameSize_, 0, newsize - frameSize_);
  delete[] buffer_;
  buffer_ = newbuffer;
  bufferPosition_ = buffer_;
  frameSize_ = newsize;
  return frameSize_;
}

int BufferedFile::SeekToFrame(size_t set) {
  return Seek( (off_t)((set * frameSize_) + offset_) );
}

int BufferedFile::ReadFrame() {
  return Read( buffer_, frameSize_ );
}

int BufferedFile::WriteFrame() {
  return Write( buffer_, (size_t)(bufferPosition_ - buffer_) );
}

void BufferedFile::GetDoubleAtPosition(double& val, size_t start, size_t end) {
  char savechar = buffer_[end];
  buffer_[end] = '\0';
  val = atof(buffer_ + start);
  buffer_[end] = savechar;
}

void BufferedFile::BufferBegin() {
  bufferPosition_ = buffer_;
}

void BufferedFile::BufferBeginAt(size_t pos) {
  bufferPosition_ = buffer_ + pos;
}

void BufferedFile::AdvanceBuffer(size_t offset) {
  bufferPosition_ += offset;
}

/** Convert text in buffer containing numerical elements with format 
  * X0Y0Z0X1Y1Z1...XNYNZN to the given double array. The width of each 
  * element should be what SetupFrameBuffer was called with, and the 
  * number of elements to read should not be greater than Nelts.
  * Newlines are skipped. Output array should be as big as Nout. 
  * Update bufferPosition after read.
  */
void BufferedFile::BufferToDouble(double* Xout, int Nout) {
  for (int element = 0; element < Nout; ++element) {
    // Advance past newlines / CR (dos)
    while (*bufferPosition_=='\n' || *bufferPosition_=='\r')
      ++bufferPosition_;
    if (*bufferPosition_ == '*') {
      mprinterr("Error: '*' encountered (atom %i", (element / 3) + 1);
      int problem_xyz = element % 3;
      if (problem_xyz == 0)      mprinterr(" X");
      else if (problem_xyz == 1) mprinterr(" Y");
      else                       mprinterr(" Z");
      mprinterr("). This indicates coordinate overflow.\n");
    }
    char *ptrend = bufferPosition_ + eltWidth_;
    char lastchar = *ptrend;
    *ptrend = '\0';
    Xout[element] = atof(bufferPosition_);
    *ptrend = lastchar;
    bufferPosition_ = ptrend;
  }
}

/** Convert given double array to ordered text in buffer. The number of
  * elements in the given array should be what SetupFrameBuffer was
  * called with. Update bufferPosition after write. 
  */
void BufferedFile::DoubleToBuffer(const double* Xin, int Nin, const char* format)
{
  int col = 0;
  for (int element = 0; element < Nin; ++element) {
    sprintf(bufferPosition_, format, Xin[element]);
    bufferPosition_ += eltWidth_;
    ++col;
    if ( col == Ncols_ ) {
      sprintf(bufferPosition_,"\n");
      ++bufferPosition_;
      col = 0;
    }
  }
  // If the coord record didnt end on a newline, print one
  if ( col != 0 ) {
    sprintf(bufferPosition_,"\n");
    ++bufferPosition_;
  }
}
