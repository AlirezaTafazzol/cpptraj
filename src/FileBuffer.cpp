#include <cstring> // strchr
#include "FileBuffer.h"
#include "CpptrajStdio.h"

// CONSTRUCTOR
FileBuffer::FileBuffer() :
  IO_(0),
  endlinebuffer_(linebuffer_ + LINE_BUF_SIZE),
  total_read_(0),
  lineptr_(linebuffer_),
  ptr_(0),
  endbuffer_(0) 
{}

/// CONSTRUCTOR - Input is FileIO class and total (uncompressed) file size.
FileBuffer::FileBuffer(FileIO* IOin, int sizeIn) :
  IO_(IOin),
  endlinebuffer_(linebuffer_ + LINE_BUF_SIZE),
  total_read_(0),
  lineptr_(linebuffer_),
  ptr_(readbuffer_),
  endbuffer_(ptr_), // This guarantees on first read buffer will be filled
  progress_(sizeIn)
{}

/** Get the next newline-terminated line from the buffer. */
const char* FileBuffer::NextLine() {
  // Reset line buffer
  lineptr_ = linebuffer_;
  // Get next line from chunk.
  while ( lineptr_ < endlinebuffer_ ) {
    // Fill buffer if needed.
    if (endbuffer_ == ptr_) {
      int Nread = IO_->Read(readbuffer_, DEFAULT_CHUNKSIZE);
      if (Nread < 1) return 0;
      total_read_ += Nread;
      progress_.Update( total_read_ );
      ptr_ = readbuffer_;
      endbuffer_ = readbuffer_ + (size_t)Nread;
    }
    // Fill line buffer
    *(lineptr_++) = *ptr_;
    if (*ptr_ == '\n') {
      *lineptr_ = '\0';
      // Position ptr at next char
      ++ptr_;
      return linebuffer_;
    }
    ++ptr_;
  }
  mprinterr("Error: FileBuffer: blowing line buffer (> %zu bytes)\n", LINE_BUF_SIZE);
  linebuffer_[LINE_BUF_SIZE - 1] = '\0';
  return linebuffer_;
}

/** Separate the current line into tokens delimited by given chars. 
  * \return Number of tokens.
  */
int FileBuffer::TokenizeLine(const char* separator) {
  if ( separator == NULL ) return 0;
  unsigned int ntokens = 0;;
  char* linechar = linebuffer_;
  bool inToken = false;
  // NOTE: Just check for newline?
  while ( *linechar != '\0' && *linechar != '\n' ) {
    if (!inToken) { // Not in token.
      if ( strchr( separator, *linechar ) == NULL ) {
        tokens_[ntokens++] = linechar; // Pointer to beginning of token.
        inToken = true;
      }
    } else {        // In a token.
      if ( strchr( separator, *linechar ) != NULL ) {
        tokens_[ntokens++] = linechar; // Pointer to end of token.
        inToken = false;
      }
    }
    ++linechar;
  }
  // If inToken is still true point to linechar as the last token
  if (inToken)
    tokens_[ntokens++] = linechar;
  // Init for NextToken
  tokens_[ntokens+1] = '\0';
  tokenptr_ = tokens_; 
  /*mprintf("DBG: Tokenize: Line=[%s]\n", linebuffer_);
  mprintf("\t%i Tokens:\n", ntokens);
  for (unsigned int t = 0; t < ntokens; ++t)
    mprintf("\t\t%u %c\n",t, *tokens_[t]);*/
  return ntokens / 2;
}

/** Following a call to TokenizeLine return char* to next token in the
  * line. Token is generated by inserting a NULL char at the current
  * token end position; this char is restored once NextToken is called
  * again.
  */
const char* FileBuffer::NextToken() {
  if (tokenptr_ == '\0') return 0;
  if (tokenptr_ != tokens_)
    *(tokenptr_[-1]) = savechar_;
  savechar_ = *(tokenptr_[1]);
  *(tokenptr_[1]) = '\0';
  char* tokenpos = tokenptr_[0];
  tokenptr_ += 2;
  return tokenpos;
}
